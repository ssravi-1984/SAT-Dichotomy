%% File: supplement.tex

\appendix

\vspace*{3in}

\begin{center}
\fbox{\fbox{\Large{\textbf{Supplementary Material}}}}
\end{center}

\bigskip\bigskip


\noindent
\textbf{Paper title:}~ Dichotomy Theorems for Hierarchical and 1-Dimensional
Periodically Specified Boolean Constraint Satisfaction Problems

\bigskip

\noindent
\textbf{Authors:}~ M. V. Marathe, H. B. Hunt III, V. Radhakrishnan, S.~S. Ravi,
D.~J. Rosenkrantz and R.~E. Stearns

\clearpage

\section{Additional Material for Section~\ref{sec:hard_3sat}}

\subsection{Statement and Proof of Theorem~\ref{th:fpn-3sat}}

\noindent
\textbf{Statement of Theorem~\ref{th:fpn-3sat}:}
(1) 1-FPN-3SAT is in NSPACE$(n)$.~
(2) There is a $\theta(n)$ size 
quasi linear time reduction from the membership problem
for  non-deterministic linearly space bounded machine (LBA) 
to the problem 1-FPN-3SAT. 
Thus 1-FPN-3SAT is {\sf PSPACE}-complete. 

\medskip

\noindent
{\bf Proof:}  

\noindent
{\em Part (1):}
We first show that the problem is in {\sf NSPACE($n$)}.
Observe that given a {\sf 1-FPN}-specification 
$\Gamma = (G(V,E), m)$, a Turing machine 
needs to maintain at any given time $t$ 
only assignments to variables at time $t$ and time $t+1$. 
Hence a non deterministic {\sf LBA}
can verify that the instance of {\sf 1-FPN-3SAT} is satisfiable as follows. At 
each step $t$ it guesses an assignment to the variables at grid point $t+1$.
It also remembers the assignment to the variables at grid point $t$. Using
these values it verifies that the clauses at time $t$ are indeed satisfied.
The number of time steps  $m$ can be kept track of using a counter of size
$O(m)$ (since $m$ is specified as a binary numeral). 
This proves that given an instance $\Gamma$ 
of {\sf 1-FPN-3SAT}, we can recognize in 
non-deterministic {\em linear } space (i.e in space $O(size(\Gamma))$) 
if the formula $G^m$ is satisfiable.

\smallskip

\noindent
{\em Part (2):}
Next, we prove {\sf 1-FPN-3SAT} is {\sf PSPACE}-hard. 
Given a non-deterministic {\sf LBA},
$M$, with input $x$ (where $|x| = n$), 
we construct an instance of {\sf 1-FPN-3SAT} $F(x)$ such that
$size(F(x)=  O(n)$,
and $x$ is accepted by $M$ if and only if $F(x,t,t+1)$ is satisfiable.
The reduction consists of two phases. 

\noindent
{\bf Phase 1:}
In the first phase, we
start with the given {\sf LBA} $M$ with input 
$x = (x_1, \ldots, x_n)$ and construct
a new {\sf LBA} $M_1$ which simulates $M$ on $x$ with the
following additional properties that
\begin{enumerate}
\item
if the {\sf LBA} $M$ does not accept $x$ then
each computation of $M_1$ on $x$ halts within $2^{c_0n}$ moves, and 
\item
if the {\sf LBA} $M$ accepts $x$ then $M_1$ has a cycling computation,
where the length of an ID never exceeds $O(|x|)$.

\end{enumerate}



$M_1$ can be constructed easily by adding an auxiliary  clock to serve 
as a counter. $M_1$ now just simulates $M$.  
If $M$ enters a final configuration, then $M_1$ repeats this
configuration. Its clear that 
$M_1$ accepts $x$
if and only if $M$ accepts $x$ and their number of
accepting computations is the same. Moreover it is easy to see that
$M_1$ has the two desired properties above.



\noindent
{\bf Phase 2:}
The second phase consists of constructing an instance 
$\Gamma = (F, M)$ of 
{\sf 1-FPN-3SAT} by a polynomial time reduction from $M_1$. 
Now we know that each ID of the Turing machine $M_1$ is 
of length $O(n)$, where $n$ is the size of the input.
Since $M_1$ is non-deterministic {\sf LBA}
we need to consider only $2^{Dn}$ different ID's for
our reduction. (Here $D$ is an appropriately chosen constant.)  
We can choose
an encoding of states and symbols of $M_1$ into words in $\{0,1\}^*$ so
that every ID of $M_1$ will consist of $c_1 \cdot n$ boolean variables where
$n=|x|$ and $c_1$ is a constant independent of $x$. Let $ID(t)$ denote
the {\sf ID} of the Turing machine at time $t$. We also have 
a set of $Dn+1$ boolean variables encoding a counter $\gamma(t)$. The counter
values range from $0$ to $2^{Dn}$. 
$F(x, t,t+1) = f_1(x,t,t+1) \wedge f_2(x,t,t+1) \wedge f_3(x, t, t+1)$. 
We discuss each of the three formulas $f_i(t,t+1)$, $1 \leq i \leq 3$.

\begin{enumerate}
\item 
The formula $f_1(x, t, t+1)$ encodes a counter which is given by 
\[\gamma(t + 1) =  (\gamma(t) + 1) \pmod{2^{Dn} +1}.\]
The intended meaning of the equation is  
that the counter resets to 0 after every $2^{Dn} +1$ time units.
It is easy to see that the counter 
can be simulated by a {\sf CNF} formula, in which each clause
has variables  that are no more than one time unit apart.
We briefly discuss how to simulate a counter here.  Let $q = Dn$
We use boolean
variables $d_q, d_{q-1}, \ldots d_0$ to simulate a counter.
The variable $d_0$ encodes the lowest order bit and the bit $d_q$ denotes the
highest order bit. We also use  boolean
variables $c_q, c_{q-1}, \ldots c_0$ to keep track of the carry bits 
required to do the addition. Let $d_i(t)$ denote
the copy of the variable $d_i$ at time unit $t$.
The set of narrow {\sf CNF} 
clauses needed to simulate the  counter  consist of the following.
The formula $f_1$ is expressed as follows:
\[f_1(x,t, t+1) \equiv (g_1 \Rightarrow h_1) \wedge (\overline{g_1} \Rightarrow h_2).\]

We describe each of the subformulas $g_1$, $h_1$ and $h_2$ in the 
following.
$g_1$ checks to see if the counter needs to be reset. If $g_1$ is true then
$h_1$ merely resets the counter; else $h_2$ increments it by one.
Hence $g_1$ is given by 
\[g_1  \equiv [(d_0(t) \wedge d_1(t) \wedge \ldots \wedge d_q(t) )\] 

The condition that counter resets to 0 after $2^{Dn}$ time units can now
be written using a CNF  formula $h_1$ as follows:
\[ h_1 \equiv (\overline{d_0(t+1)} \wedge \overline{d_1(t+1)} \wedge  
\ldots \wedge \overline{d_q(t+1)})].\]

As mentioned  earlier,
we have $q+1$ carry bits to do the addition. Let the carry bits
corresponding to the counter $\gamma(t)$ be $c_q, \ldots c_0$. Now the second 
part of the conjunct can be expressed as follows. $h_2$ is now defined
as a conjunction of the following clauses

\[\left(d_0(t+1) = \overline{d_0(t)} \right) \wedge
\bigwedge_{i= 1 }^{i = q} 
\left((d_i(t+1) = [\overline{d_i(t)} \wedge c_i(t+1)]+
               [d_i(t) \wedge \overline{c_i(t+1)}]) \right)\bigwedge \]
\[\left( c_0(t+1) = d_0(t) \right) \wedge  \bigwedge_{i =1}^{ i = q}  
\left(c_{i+1}(t+1) = d_i(t) \wedge c_i(t+1) \right) \]

Observe that we have $O(n)$ boolean variables encoding the counter.
Therefore, the size of each of the formulas $g_1, h_1$ and $h_2$ is linear
in the size of the input.
Furthermore each of the formulas $g_1$, $h_1$ and $h_2$ contain a linear
(in the number of boolean variables used to simulate the counter)  number
of clauses.  As a result, the implications 
$ (g_1 \Rightarrow h_1)$ and $(\overline{g_1} \Rightarrow h_2)$ can be written
in equivalent {\sf 3CNF} form using additional temporary variables.
The size of each {\sf 3CNF} formula is linear in original size of
the implications. 
Hence the size of $f_1(x,t,t+1)$ is also linear
in the size of the input. 


\item 
The formula $f_2(x, t, t+1)$ enforces the condition that when the
counter value is 0, the variables $X(t)$ encode the starting ID of the
Turing machine.
Here, $start(ID(t))$ denotes a  {\sf CNF} 
formula which checks if $ID(t)$ is the initial ID of the machine.
Thus $f_2(t, t+1)$  is a {\sf 3CNF} formula which
encodes the  implication $(\gamma(t) =0) \Rightarrow start(ID(t))$.\\ 
Again, we can verify that $f_2(x, t, t+1)$ 
can be written as a {\sf 3CNF} formula in polynomial time. Again by standard
techniques it follows that the formula $f_2(x,t, t+1)$ is of size $O(n)$. 



\item
The formula $f_3(x, t, t+1)$ is needed to ensure that starting at 
the second ID, each subsequent ID
of $M_1$ follows from the previous ID by using the
transition function of $M_1$.
(Recall that the notation $(X {\vdash}_M^j Y)$ means that machine $M$, 
starting with ID $X$, can produce the ID $Y$ in exactly $j$ steps.) 
Thus $f_3(t)$ is a {\sf 3CNF} formula encoding the following implication. 
\[(1 \leq \gamma(t) \leq 2^{Dn}) \Rightarrow (ID(t-1) {\vdash}_M ID(t)) \]
The function ($ID(t) {\vdash}_M ID(t+1)$) can be expressed
by {\sf 3CNF} formula whose sizes are linear in $n$ as shown in \cite{Hu73a}.
Moreover the {\sf 3CNF} formula depends on the current value of the counter. 
Hence the {\sf CNF} formula $f_3(x, t, t+1)$ is  
narrow periodic formula, since the clauses  at time $t$  would contain
variables only from times $t$ and $t+1$.
\end{enumerate}

\noindent
The expanded finite periodic {\sf 3SAT} 
instance is $\bigwedge_{t =0}^N F(x,t, t+1)$,
where $N = 2^{2Dn}$.

We now prove the correctness of our reduction.
If the Turing machine $M$ accepts $x$ then we know that 
$M_1$ has a cycling computation. 
Hence by setting $d_t =0$, we can  ensure that $f_2(0)$ is satisfied.
The consistency condition now forces the formula to be satisfiable 
Conversely, assume that the formula is satisfiable. 
Since $D$ ( and hence $N$) are 
suitably large integers, it is  guaranteed that the  simulation
must be carried out for enough steps so that the Turing machine $M_1$
goes through the sequence $d_t =0, d_t = 1, d_t = 2, \cdots d_t = 2^{Dn}$. 
This implies that  the formulas $f_2(t)$ and $f_3(t)$
would be true from then on 
and therefore the  Turing machine $M$ accepts $x$. \hfill\QED
