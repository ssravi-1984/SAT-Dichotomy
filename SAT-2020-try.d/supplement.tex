%% File: supplement.tex

\appendix

\vspace*{2in}

\begin{center}
\fbox{\fbox{\Large{\textbf{Supplementary Material}}}}
\end{center}

\bigskip\bigskip\bigskip


\noindent
\textbf{Paper title:}~ Dichotomy Theorems for Hierarchical and 1-Dimensional
Periodically Specified Boolean Constraint Satisfaction Problems

\bigskip

\noindent
\textbf{Authors:}~ M. V. Marathe, H. B. Hunt III, V. Radhakrishnan, S.~S. Ravi,
D.~J. Rosenkrantz and R.~E. Stearns

\clearpage

\section{Additional Material for Section~\ref{sec:hard_3sat}}
\label{sec:appA}

\subsection{Statement and Proof of Theorem~\ref{th:fpn-3sat}}

\noindent
\textbf{Statement of Theorem~\ref{th:fpn-3sat}:}
(1) 1-FPN-3SAT is in NSPACE$(n)$.~
(2) There is a $\theta(n)$ size 
quasi linear time reduction from the membership problem
for  non-deterministic linearly space bounded machine (LBA) 
to the problem 1-FPN-3SAT. 
Thus 1-FPN-3SAT is {\sf PSPACE}-complete. 

\medskip

\noindent
{\bf Proof:}  

\noindent
{\em Part (1):}
We first show that the problem is in {\sf NSPACE($n$)}.
Observe that given a {\sf 1-FPN}-specification 
$\Gamma = (G(V,E), m)$, a Turing machine 
needs to maintain at any given time $t$ 
only assignments to variables at time $t$ and time $t+1$. 
Hence a non deterministic {\sf LBA}
can verify that the instance of {\sf 1-FPN-3SAT} is satisfiable as follows. At 
each step $t$ it guesses an assignment to the variables at grid point $t+1$.
It also remembers the assignment to the variables at grid point $t$. Using
these values it verifies that the clauses at time $t$ are indeed satisfied.
The number of time steps  $m$ can be kept track of using a counter of size
$O(m)$ (since $m$ is specified as a binary numeral). 
This proves that given an instance $\Gamma$ 
of {\sf 1-FPN-3SAT}, we can recognize in 
non-deterministic {\em linear } space (i.e in space $O(size(\Gamma))$) 
if the formula $G^m$ is satisfiable.

\smallskip

\noindent
{\em Part (2):}
Next, we prove {\sf 1-FPN-3SAT} is {\sf PSPACE}-hard. 
Given a non-deterministic {\sf LBA},
$M$, with input $x$ (where $|x| = n$), 
we construct an instance of {\sf 1-FPN-3SAT} $F(x)$ such that
$size(F(x)=  O(n)$,
and $x$ is accepted by $M$ if and only if $F(x,t,t+1)$ is satisfiable.
The reduction consists of two phases. 

\noindent
{\bf Phase 1:}
In the first phase, we
start with the given {\sf LBA} $M$ with input 
$x = (x_1, \ldots, x_n)$ and construct
a new {\sf LBA} $M_1$ which simulates $M$ on $x$ with the
following additional properties that
\begin{enumerate}
\item
if the {\sf LBA} $M$ does not accept $x$ then
each computation of $M_1$ on $x$ halts within $2^{c_0n}$ moves, and 
\item
if the {\sf LBA} $M$ accepts $x$ then $M_1$ has a cycling computation,
where the length of an ID never exceeds $O(|x|)$.

\end{enumerate}



$M_1$ can be constructed easily by adding an auxiliary  clock to serve 
as a counter. $M_1$ now just simulates $M$.  
If $M$ enters a final configuration, then $M_1$ repeats this
configuration. Its clear that 
$M_1$ accepts $x$
if and only if $M$ accepts $x$ and their number of
accepting computations is the same. Moreover it is easy to see that
$M_1$ has the two desired properties above.



\noindent
{\bf Phase 2:}
The second phase consists of constructing an instance 
$\Gamma = (F, M)$ of 
{\sf 1-FPN-3SAT} by a polynomial time reduction from $M_1$. 
Now we know that each ID of the Turing machine $M_1$ is 
of length $O(n)$, where $n$ is the size of the input.
Since $M_1$ is non-deterministic {\sf LBA}
we need to consider only $2^{Dn}$ different ID's for
our reduction. (Here $D$ is an appropriately chosen constant.)  
We can choose
an encoding of states and symbols of $M_1$ into words in $\{0,1\}^*$ so
that every ID of $M_1$ will consist of $c_1 \cdot n$ Boolean variables where
$n=|x|$ and $c_1$ is a constant independent of $x$. Let $ID(t)$ denote
the {\sf ID} of the Turing machine at time $t$. We also have 
a set of $Dn+1$ Boolean variables encoding a counter $\gamma(t)$. The counter
values range from $0$ to $2^{Dn}$. 
$F(x, t,t+1) = f_1(x,t,t+1) \wedge f_2(x,t,t+1) \wedge f_3(x, t, t+1)$. 
We discuss each of the three formulas $f_i(t,t+1)$, $1 \leq i \leq 3$.

\begin{enumerate}
\item 
The formula $f_1(x, t, t+1)$ encodes a counter which is given by 
\[\gamma(t + 1) =  (\gamma(t) + 1) \pmod{2^{Dn} +1}.\]
The intended meaning of the equation is  
that the counter resets to 0 after every $2^{Dn} +1$ time units.
It is easy to see that the counter 
can be simulated by a {\sf CNF} formula, in which each clause
has variables  that are no more than one time unit apart.
We briefly discuss how to simulate a counter here.  Let $q = Dn$
We use Boolean
variables $d_q, d_{q-1}, \ldots d_0$ to simulate a counter.
The variable $d_0$ encodes the lowest order bit and the bit $d_q$ denotes the
highest order bit. We also use  Boolean
variables $c_q, c_{q-1}, \ldots c_0$ to keep track of the carry bits 
required to do the addition. Let $d_i(t)$ denote
the copy of the variable $d_i$ at time unit $t$.
The set of narrow {\sf CNF} 
clauses needed to simulate the  counter  consist of the following.
The formula $f_1$ is expressed as follows:
\[f_1(x,t, t+1) \equiv (g_1 \Rightarrow h_1) \wedge (\overline{g_1} \Rightarrow h_2).\]

We describe each of the subformulas $g_1$, $h_1$ and $h_2$ in the 
following.
$g_1$ checks to see if the counter needs to be reset. If $g_1$ is true then
$h_1$ merely resets the counter; else $h_2$ increments it by one.
Hence $g_1$ is given by 
\[g_1  \equiv [(d_0(t) \wedge d_1(t) \wedge \ldots \wedge d_q(t) )\] 

The condition that counter resets to 0 after $2^{Dn}$ time units can now
be written using a CNF  formula $h_1$ as follows:
\[ h_1 \equiv (\overline{d_0(t+1)} \wedge \overline{d_1(t+1)} \wedge  
\ldots \wedge \overline{d_q(t+1)})].\]

As mentioned  earlier,
we have $q+1$ carry bits to do the addition. Let the carry bits
corresponding to the counter $\gamma(t)$ be $c_q, \ldots c_0$. Now the second 
part of the conjunct can be expressed as follows. $h_2$ is now defined
as a conjunction of the following clauses

\[\left(d_0(t+1) = \overline{d_0(t)} \right) \wedge
\bigwedge_{i= 1 }^{i = q} 
\left((d_i(t+1) = [\overline{d_i(t)} \wedge c_i(t+1)]+
               [d_i(t) \wedge \overline{c_i(t+1)}]) \right)\bigwedge \]
\[\left( c_0(t+1) = d_0(t) \right) \wedge  \bigwedge_{i =1}^{ i = q}  
\left(c_{i+1}(t+1) = d_i(t) \wedge c_i(t+1) \right) \]

Observe that we have $O(n)$ Boolean variables encoding the counter.
Therefore, the size of each of the formulas $g_1, h_1$ and $h_2$ is linear
in the size of the input.
Furthermore each of the formulas $g_1$, $h_1$ and $h_2$ contain a linear
(in the number of Boolean variables used to simulate the counter)  number
of clauses.  As a result, the implications 
$ (g_1 \Rightarrow h_1)$ and $(\overline{g_1} \Rightarrow h_2)$ can be written
in equivalent {\sf 3CNF} form using additional temporary variables.
The size of each {\sf 3CNF} formula is linear in original size of
the implications. 
Hence the size of $f_1(x,t,t+1)$ is also linear
in the size of the input. 


\item 
The formula $f_2(x, t, t+1)$ enforces the condition that when the
counter value is 0, the variables $X(t)$ encode the starting ID of the
Turing machine.
Here, $start(ID(t))$ denotes a  {\sf CNF} 
formula which checks if $ID(t)$ is the initial ID of the machine.
Thus $f_2(t, t+1)$  is a {\sf 3CNF} formula which
encodes the  implication $(\gamma(t) =0) \Rightarrow start(ID(t))$.\\ 
Again, we can verify that $f_2(x, t, t+1)$ 
can be written as a {\sf 3CNF} formula in polynomial time. Again by standard
techniques it follows that the formula $f_2(x,t, t+1)$ is of size $O(n)$. 



\item
The formula $f_3(x, t, t+1)$ is needed to ensure that starting at 
the second ID, each subsequent ID
of $M_1$ follows from the previous ID by using the
transition function of $M_1$.
(Recall that the notation $(X {\vdash}_M^j Y)$ means that machine $M$, 
starting with ID $X$, can produce the ID $Y$ in exactly $j$ steps.) 
Thus $f_3(t)$ is a {\sf 3CNF} formula encoding the following implication. 
\[(1 \leq \gamma(t) \leq 2^{Dn}) \Rightarrow (ID(t-1) {\vdash}_M ID(t)) \]
The function ($ID(t) {\vdash}_M ID(t+1)$) can be expressed
by {\sf 3CNF} formula whose sizes are linear in $n$ as shown in \cite{Hu73a}.
Moreover the {\sf 3CNF} formula depends on the current value of the counter. 
Hence the {\sf CNF} formula $f_3(x, t, t+1)$ is  
narrow periodic formula, since the clauses  at time $t$  would contain
variables only from times $t$ and $t+1$.
\end{enumerate}

\noindent
The expanded finite periodic {\sf 3SAT} 
instance is $\bigwedge_{t =0}^N F(x,t, t+1)$,
where $N = 2^{2Dn}$.

We now prove the correctness of our reduction.
If the Turing machine $M$ accepts $x$ then we know that 
$M_1$ has a cycling computation. 
Hence by setting $d_t =0$, we can  ensure that $f_2(0)$ is satisfied.
The consistency condition now forces the formula to be satisfiable 
Conversely, assume that the formula is satisfiable. 
Since $D$ ( and hence $N$) are 
suitably large integers, it is  guaranteed that the  simulation
must be carried out for enough steps so that the Turing machine $M_1$
goes through the sequence $d_t =0, d_t = 1, d_t = 2, \cdots d_t = 2^{Dn}$. 
This implies that  the formulas $f_2(t)$ and $f_3(t)$
would be true from then on 
and therefore the  Turing machine $M$ accepts $x$. \hfill\QED

\subsection{Statement and Proof of Corollary~\ref{th:l3sathard}}

\noindent
\textbf{Statement of Corollary~\ref{th:l3sathard}:}~
(1) The problem 1-FPN(BC)-3SAT is in NSPACE$(n)$.
There is a quasi-linear
time linear size reduction from the membership problem for non-deterministic
LBA to 1-FPN(BC)-3SAT.
Thus the  problem 1-FPN(BC)-3SAT is PSPACE-complete.~
(2)
The problem L-3SAT is in DSPACE$(n)$.
There is a square time
square size reduction from the membership problem for non-deterministic
LBA to L-3SAT. Thus the  problem L-3SAT is PSPACE-complete.

\medskip

\noindent
{\bf Proof:}~
The {\sf PSPACE}-hardness of {\sf 1-FPN-3SAT(BC)} follows 
immediately from Theorem \ref{th:fpn-3sat}.
By arguments similar to those
presented in the proof of Theorem \ref{th:fpn-3sat}, 
the problem {\sf 1-FPN(BC)-3SAT}  is seen to be in {\sf NSPACE(n)}.

The {\sf PSPACE}-hardness of  the problem {\sf L-3SAT} follows
from Theorem \ref{th:fpn-3sat} and the Translation theorem. Specifically,
there is a $O(n^2)$ size reduction from the membership problem for a  
non-deterministic {\sf LBA} to the problem  {\sf L-3SAT}.
We now show that {\sf L-3SAT} is solvable in {\sf DSPACE(n)}
by using backtracking. 
Let $\displaystyle{F_i(X^i)=(\bigwedge_{1 \leq j \leq  l_i} 
F_{i_j}(X^i_j,Z^i_j)) \bigwedge f_i(X^i,Z^i)}$.
Here $0 \leq i_j <i$.
Given an assignment of $X^i$, 
we evaluate $F_i(X^i)$ as follows:
For each assignment of $Z^i$:
For $1 \leq j \leq  l_i$, 
check if $F_{i_j}(X^i_j,Z^i_j)$ is true and store the values of 
$F_{i_j}(X^i_j,Z^i_j)$.
These values require space linear in $l_i$. Finally evaluate $f_i(X^i,Z^i)$.
This evaluation can be carried out in deterministic space linear in the size of
$f_i$ since it is a {\sf CNF} formula.
If no such assignment to $Z^i$ is found, 
$F_i(X^i)$ is false. Otherwise, $F_i(X^i)$ is true.
Thus, if $F_k$ for $k < i$, can be solved in space linear in their
representation, $F_i$ can be solved in space linear in its representation,
since the space needed to $F_i$ in the space to store the values of
$X^i$, $Z^i$ and the intermediate results $F_{i_j}(X^i_j,Z^i_j)$. This
allows us to do the backtracking in {\sf DSPACE(n)}.
$F_1$ can be solved in {\sf DSPACE(n)}  since it is a {\sf CNF} formula.
Hence by induction on the number of levels in the hierarchy, membership of
the problem {\sf L-3SAT} in {\sf DSPACE(n)} follows. \hfill\QED

\iffalse
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Decided to keep this proof in the main part.
%%%
\subsection{Statement and Proof of Corollary~\ref{th:pn3sat}}

\noindent
\textbf{Statement of Corollary~\ref{th:pn3sat}:}~
The problem 1-PN-3SAT is in NSPACE$(n)$.
There is a quasi-linear
time linear size reduction from the membership problem for non-deterministic
LBA to 1-FPN(BC)-3SAT.
Thus the  problem 1-PN-3SAT is PSPACE-complete. 

\medskip

\noindent
{\bf Proof:}  
Orlin \cite{Or82a} and Papadimitriou \cite{Pa94} have shown that
the problem {\sf 1-PN-3SAT} is in {\sf NSPACE(n)}. 
We only prove that the problem is {\sf PSPACE}-hard by a linear size
reduction from the membership problem for a non-deterministic {\sf LBA}.
(In contrast, The reduction in \cite{Or82a} is a square size reduction.)  
Observe that if an instance of {\sf 1-PN-3SAT} has a solution
then the assignment to the variables is periodic. If there are $n$ variables
in the static formula we can have no more than $2^{2n}$ distinct assignments to
the variables to consider. 
Hence starting from  an instance of {\sf 1-FPN-3SAT} 
$(F(U,C(i, i+1)),m)$ where $n = |U|$   and $m = 2^{2n}$ we  see that 
$F^m$ is satisfiable if and only if $F^{\infty}$ is satisfiable.
This completes the proof that the problem {\sf 1-PN-3SAT} is 
{\sf PSPACE}-complete. \hfill\QED
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi

\subsection{Statement and Proof of Theorem~\ref{th:fpn3satwnhard}}

\noindent
\textbf{Statement of Theorem~\ref{th:fpn3satwnhard}:}~
There is a quasi-linear
time linear size reduction from the membership problem for deterministic
LBA to problems 1-FPN(BC)-3SATWN and  1-FPN(BC)-3SATWP.
Thus the problems 1-FPN(BC)-3SATWN and  1-FPN(BC)-3SATWP PSPACE-complete.

\medskip

\noindent
{\bf Proof:} 

\smallskip

\noindent
Part (1):~
We prove  this part for the problem {\sf 1-FPN(BC)-3SATWN}. 
The proof for {\sf 1-FPN(BC)-3SATWP} is similar.

The membership of the problem {\sf 1-FPN(BC)-3SATWN} in {\sf NSPACE(n)} 
follows since the problem {\sf 1-FPN(BC)-3SAT} is in {\sf NSPACE(n)}.  
To prove that {\sf 1-FPN(BC)-3SATWN} is {\sf PSPACE}-hard we give a linear size
reduction from the acceptance problem of a {\bf deterministic} {\sf LBA}.
Let $ID(t)$ denote the  instantaneous description of a
a deterministic {\sf LBA} $M$ at time time $t$.
Given $M$ and input $x$ such that $|x| = n$ we create
an instance $(F(x,t,t+1),m)$ of {\sf 1-FPN(BC)-3SATWN}, such that 
$\wedge_{t = 0}^{t = N} F(x, t, t+1)$ is 
satisfiable if and only if $M$ accepts $x$. 
The reduction is similar to one presented for  {\sf 1-FPN-3SAT}. 
The formulas encoding $(ID(t) \vdash ID(t+1))$, and $start(ID(t))$
can  be represented by a weakly negative formula
as in the {\sf P}-hardness of {\sf UNIT} given in \cite{JL77}. 
By negating all literals, we can 
obtain a weakly positive formula proving the {\sf PSPACE}-hardness of 
{\sf L-3SATWP}. Let $a \in \{ \# \} \cup T \cup  (S \times T)$, where 
$T$ denotes the tape symbols and $S$ denotes the set of states. 
Let $P^a_i(t)$ be a Boolean variable which means that the contents
of $i^{th}$ tape cell at time $t$ is $a$. Observe that for a given value of $t$
the number of variables $P^a_i(t)$ is $O(n)$. 
The formula $g(x,0)$ is now represented as
\[g(x, 0) \equiv 
\left( P_{1}^{(q_0,a_1)}(0) \wedge P_{2}^{a_2}(0),\ldots \wedge 
P_{n}^{a_n}(0) \right) \bigwedge_{i} \left(\bigwedge_{a \neq b} 
(~\overline{P_{i}^a(0)} \vee  ~\overline{P_{i}^b(0)}) \right)\]
The first part represents the condition that the first ID corresponds to the
input and the second part represents the condition that one position
cannot contain two distinct symbols. Hence, the above formula represents the
condition that the first $ID$ is correct.  Also observe that since the number 
of tape symbols are constant, the size of $g(x,0)$ is linear in the size of 
the input.

Next, we represent  $(ID(t) {\vdash}_M ID(t+1))$
as follows:
Let $f:(T \cup (S \times T))^3 \rightarrow T \cup (S \times T)$ be the finite
function such that if positions $i-1$, $i$ and $i+1$ of the $ID(t)$ 
contain $a$, $b$ and $c$ respectively, then position $i$ of the $ID(t+1)$ 
must contain $f(a,b,c)$. The determinism of $M$ ensures that
$f$ is single valued. We express the requirement that $ID(t+1)$ 
is appropriately  determined by $ID(t)$ as follows:


\[g(x, t,t+1) \equiv  \bigwedge_{i =1}^{ i = n} ~~~ \bigwedge_{a,b,c \in T} 
\left(\left(~P_{i-1}^{a}(t) \wedge P_{i}^{b}(t) \wedge 
P_{i+1}^{c}(t) \right) \Rightarrow ~P_{i}^{f(a,b,c)}(t+1) \right) \]
which can be written as an equivalent weakly negative formula as follows:

\[g(x, t,t+1) \equiv  \bigwedge_{i =1}^{ i = n} ~~~ \bigwedge_{a,b,c \in T} 
\left(~\overline{P_{i-1}^{a}(t)} \vee \overline{P_{i}^{b}(t)}
\vee \overline{P_{i+1}^{c}(t)}  \vee ~P_{i}^{f(a,b,c)}(t+1) \right) \]

Now, each four literal clauses replaced by equivalent three literals clauses
by adding new auxiliary variables $T^{f(a,b,c)}_{i}(t)$. Therefore
$g(x, t,t+1)$  is rewritten as 

\[ \bigwedge_{i =1}^{ i = n} ~~~ \bigwedge_{a,b,c \in T} 
\left(
\left(~\overline{P_{i-1}^{a}(t)} \vee \overline{P_{i}^{b}(t)}
\vee T_{i}^{f(a,b,c)}(t) \right)
\wedge 
\left( \overline{T_{i}^{f(a,b,c)}(t)} \vee
\overline{P_{i+1}^{c}(t)}  \vee ~P_{i}^{f(a,b,c)}(t+1) \right)\right) \]


$F(x,t,t+1) = g(x, 0) \cup g(x,t, t+1)$. Let $N = 2^{2Dn}$.
The instance output by the reduction is $(F(x,t, t+1), N)$
The corresponding expanded formula is given as 
\[ F^N(x) = g(x, 0) \wedge \bigwedge_{t = 0}^{N}g(x, t, t+1). \] 
Again observe that since the number of tape symbols are constant and $i$ 
varies  from $1$ to $n$,  
the size of the formula $g(x, t, t+1)$ is linear in the size of the input.
Also, observe that representation of $N$ is of size $O(n)$. Therefore
the size of the instance obtained as a result of the reduction is $O(n)$.
Here, 
$N$ is suitably chosen large integer so that the simulation can be carried 
out for enough number of steps. This completes the proof of the 
first part. \hfill\QED

\section{Additional Material for Section~\ref{sec:poly}}
\label{sec:appB}


%\noindent
\subsection{Solvability of $\alpha$-2SAT,
$\alpha$-{\sf 3SAT1WN} and $\alpha$-{\sf 3SAT1WP}}

Here, we establish the polynomial time solvability of the problems 
$\alpha$-{\sf 2SAT},$\alpha$-{\sf 3SAT1WN} and $\alpha$-{\sf 3SAT1WP} 
and $\alpha$-{\sf SAT(S)} 
when every relation in {\sf S} is bijunctive or weakly positive or 
weakly negative.
Our algorithms are based on the work of Davis and Putnam \cite{DP},
who gave a polynomial time algorithm to solve the problem {\sf 2SAT}.


We first review the method of Davis and Putnam\cite{DP} to eliminate clauses
and variables. These rules can be used on any {\sf 3CNF}  formula and 
are described  in the procedure \ref{dp:alg}.

\smallspacing
{\small
\begin{figure}[tbp]
\rule{\textwidth}{0.01in}

\noindent
{\bf Procedure Clause-Elimination} 

\noindent
{\bf Input:} {\it A 3CNF formula } $F$ {\em such that one of the conditions
in Lemma \ref{le:putback} hold.}

\noindent
{\bf Output:} {\bf Yes} {\em if and only if $F$ is satisfiable}.
\begin{enumerate}
\item
Set  {\em flag = false} and {\em satisfy = 0}
\item

{\bf While} $F$ is empty or {\em flag = false} {\bf do}

\begin{enumerate}
\item
{\bf If} $F$ contains one literal clauses {\bf then} {\bf do}
\begin{enumerate}
\item
{\bf If} a formula $F$ in {\sf CNF} 
contains a variable $v$ as a one literal clause and
also contains $\overline{v}$ as a one literal clause, 
then  set {\em flag = done}.

\noindent
{\bf Remark:} It is easy to see that in this case $F$ is unsatisfiable. 

\item 
If case (a) does not apply, and a variable $v$ appears as a clause in a 
{\sf CNF}
formula, then modify $F$ by deleting all clauses that contain $v$
unnegated, and deleting all occurrences of $\overline{v}$ from the remaining
clauses, to obtain a new formula $F_1$.

\noindent
{\bf Remark:} $F_1$ is satisfiable if and only if  $F$ is satisfiable. 

\item
Set $F = F_1$.

\item
{\bf If} $F$ is empty then set {\em flag = done}; {\em satisfy = 1}.

\item
If case (a) does not apply, and  $\overline{v}$ appears as a clause 
in a {\sf CNF}
formula, then modify $F$ by deleting all clauses that contain 
$\overline{v}$
unnegated, and deleting all occurrences of $v$ from the remaining
clauses, to obtain a new formula $F_1$ 

\noindent
{\bf Remark:} $F_1$ is satisfiable if and only if $F$ is satisfiable.

\item
Set $F = F_1$.

\item
{\bf If} $F$ is empty then set {\em flag = done}; {\em satisfy = 1}.
\end{enumerate}

\item
If a variable $v$ occurs only unnegated in a formula $F$ or if $v$ occurs 
only negated, then  delete all clauses containing the literal  $v$ to
obtain $F_1$. 

\item
If $F_1$ empty, then set {\em flag = done} and {\em satisfy = 1}. 
Else  set $F = F_1$.


\noindent
{\bf Remark:} $F_1$ is satisfiable if and only if  $F$ is satisfiable.
If $F_1$ empty, then $F$ is satisfiable.

\item
Eliminating variables: 
\begin{enumerate}
\item
Let $A_1$ denote the formula which is a conjunction of clauses in $F$ 
which contain $v$. Then $A$ is obtained from $A_1$ by deleting $v$ from each
clause in $A_1$. Similarly, $B$ be the formula which is obtained after 
deleting from each clause in $B_1$ the occurrence of $\overline{v}$. 

\item
Let $R$ be a conjunction of clauses which contain neither $v$ nor 
$\overline{v}$. 

\noindent
{\bf Remark:} 
Then the original formula $F$ can be put in the form:
$(A \vee v) \wedge (B \vee \overline{v}) \wedge R$.
$F$ is satisfiable if and only if  $(A \vee B) \wedge R$ is satisfiable.

\item
Convert  $(A \vee B) \wedge R$ into an equivalent 3CNF formula $F_1$ as
outlined in Lemma \ref{le:putback}.

\noindent
{\bf Remark:}
The formula $(A \vee B) \wedge R$ can be converted back into {\sf 3CNF} 
by using the distributive law provided that
the formula $F$ only contains 2 literal clauses or if $F$ is 1-weakly positive
or if $F$ is 1-weakly negative as shown in Lemma~\ref{le:putback}. 

\item
Set $F = F_1$.
\end{enumerate}
\end{enumerate}

\item
{\bf If} {\em satisfy = 1} {\bf then} {\bf return Yes}\\
{\bf else} {\bf return no}.
\end{enumerate}
\refstepcounter{xalgcount}\label{dp:alg}
\begin{center}
Algorithm~\ref{dp:alg}: Details of the Davis Putnam algorithm to eliminate
variables from a {\sf 3CNF} formula in which the conditions of Lemma
\ref{le:putback} hold.
\end{center}
\vspace*{-.2in}
\rule{\textwidth}{0.01in}
\end{figure}
}

\newspacing


\begin{lemma}\label{le:putback}
Let Step (3) in Algorithm \ref{dp:alg} be applied to eliminate 
a variable $v$ in a  3CNF formula $F$ of one of the following types
to obtain a new formula $F'$: \\
(a) the formula $F$ only contains 2 literal clauses, \\
(b) $F$ is 1-weakly positive 3CNF formula, \\
(c) $F$ is 1-weakly negative 3CNF formula. 
Then, 
$F'$ can be converted in polynomial time 
into an equivalent 3CNF formula of the {\bf same} type as the original formula
$F$. 
\end{lemma}

\noindent
{\bf Proof:}
Given the {\sf 3CNF} formula $F(C,V)$ with the variable $v$, let
$A_v$ be  the clauses in which $v$ appears negated,
$B_v$ be the clauses in which $v$ appears unnegated and 
$R$ be  the clauses in which $v$ does not appear. Let $A$ and $B$  
be the clauses 
obtained by deleting $v$ from each clause in $A_v$ and 
$\overline{v}$ from each clause in $B_v$ respectively.
Thus $F=(A \vee v) \wedge (B \vee \overline{v}) \wedge R$, 
where $A$, $B$, and $R$ 
are CNF formulae which are free of $v$. 
Then $F$ is satisfiable if and only if 
$F'=(A \vee B) \wedge R$ is satisfiable.
We now consider three cases in which $F'$ can be expressed as an
equivalent 3CNF formula in polynomial time.

\noindent
{\bf Case 1:} {\em $F$ is a {\sf 2CNF} formula.}\\
Since we obtained $A$ and $B$ from $A_v$ and $B_v$ respectively by deleting 
a variable it follows that  $A$ and $B$ are {\sf CNF} formulas 
in which each clause has 1 literal.
Let $A= u_1 \wedge u_2 \wedge \ldots \wedge u_k$ and
$B=v_1 \wedge v_2 \wedge \ldots \wedge v_l$ where $u_i$ and $v_i$ are literals.
Then $(A \vee B)$ can be expressed as a {\sf 2CNF} formula with all clauses of
the form $(u_i \vee v_j),1 \leq i \leq k, 1 \leq j \leq l$. Hence
$F'$ can also be expressed as a {\sf 2CNF} formula.

\noindent
{\bf Case 2:}  {\em $F$ is a 1-weakly positive formula.}\\
In this case, $A$ is a {\sf CNF} formula in which each clause 
either has at most 2 unnegated literals or 1 negated literal.
Similarly, $B$ is a {\sf CNF} formula in which each clause has 
either has at most 1 unnegated literal and has no negated literals.
Let $A= c_1 \wedge c_2 \wedge \ldots \wedge c_k$ and
$B=c'_1 \wedge c'_2 \wedge \ldots \wedge c'_l$ where each
$c_i$ is of the form $(u_i \vee u_i')$ or $\overline{u_i}$, and each $c'_i$ is 
of the form $v_i$. Here $u_i$, $u_i'$ and $v_i$ are variables.
Then $(A \vee B)$ can be expressed as a 1-weakly positive {\sf 3CNF} 
formula with all clauses of
either of the form $(\overline{u_i} \vee v_j)$ or of the form
$(u_i \vee u'_i \vee v_j)$ for $1 \leq i \leq k, 1 \leq j \leq l$. Hence
$F'$ can also be expressed as a 1-weakly positive {\sf 3CNF} formula.\\

\noindent
{\bf Case 3:}  $F$ is a 1-weakly negative formula.\\
This case can be handled similar to Case 2 except that each clause in $A$
has either at most 1 negated literals and no unnegated
literals, and each clause in $B$ has at most 2 negated literals or at most
1 unnegated literal. \hfill\QED


\subsubsection*{Solving $\alpha$-2SAT}
We now prove the polynomial time solvability of the problems {\sf L-2SAT}and
{\sf L-SAT$_c$(S)}, when every relation in $S$ is bijunctive. 
The procedure is described in Algorithm~\ref{l2sat:alg}.



\smallspacing
{\small
\begin{figure}[tbp]
\rule{\textwidth}{0.01in}

\noindent
{\bf Algorithm ALG-L2SAT} 

\noindent
{\bf Input:} {\it An L-specification} $F = (F_1, \ldots , F_n)$
{\it of a 2SAT formula } $E(F)$.  

\noindent
{\bf Output:} {\bf Yes} {\it if and only if $E(F)$ is satisfiable.} 

\begin{enumerate}

\item
Repeat the following steps for $1 \leq i \leq n$.

\begin{enumerate}


\item
Let $F_{i_1}, \ldots, F_{i_k}$ denote the non-terminals called in $F_i$.
Replace each of the $F_{i_j}$ by the smaller set of equations $F^b_{i_j}$
that has been already computed.

\noindent
{\bf Remark:} Observe that $F_1$ does not call any non-terminal. 
The sizes of $F_{i_j}$, $ 1 \leq j \leq k$ is $O(n_{i_j}^2)$, since
there can be only $O(n^2)$ distinct {\sf 2CNF}  that can be formed
from a set of $n$ variables. 


\item 
Let $G_i(X^i)$ represent the set of 2CNF clauses   over $X^i \cup Z^i$
obtained as a result of substitution.


\item
{\bf If} ( $ i < n  $) {\bf do}
\begin{itemize}
\item
Eliminate the variables which are not input variables to $F_i$ 
using  Algorithm \ref{dp:alg} to
remove one literal and two literal clauses to obtain $F^b_i$.

\noindent
{\bf Remark:} The variables of $F^b_i$ are the input variables of $F_i$
and the size of $F^b_i$ is bounded by $O(n_i^2)$, where $n_i$ represent
the temporary variables in the specification of $F_i$.

\end{itemize}
{\bf else}
\begin{itemize}
\item
Output {\bf Yes} if and only if the formula $G_n$ is satisfiable.
\end{itemize}

\end{enumerate}

\end{enumerate}
\refstepcounter{xalgcount}\label{l2sat:alg}
\begin{center}
Algorithm~\ref{l2sat:alg}: Details of the algorithm to solve {\sf L-2SAT}.
\end{center}
\vspace*{-.2in}
\rule{\textwidth}{0.01in}
\end{figure}
}
\newspacing



\subsubsection*{Proof of Correctness}




\begin{theorem}\label{th:h2satseasy}
\begin{enumerate}
\item
Given an instance $F = (F_1, \ldots, F_n)$ of the problem L-2SAT, 
the algorithm ALG-L-2SAT decides 
in polynomial time if $F$ is satisfiable. 
\item
There is a polynomial time algorithm for solving the problem L-SAT(S)
when every relation in S is bijunctive.
\end{enumerate}
\end{theorem}

\noindent
{\bf Proof:}
Part (1): 
Consider an instance of {\sf L-2SAT}.
Let the formula be of the form $F = (F_1,...,F_n)$ where each
$F_i$ is a formula consisting of calls to $F_j (1 \leq j < i)$ and a
{\sf 2CNF} formula $f_i$. 
For each $F_i$, the  {\sf 2CNF} formula $F^b_i$, 
obtained in Step 1(c) of the Algorithm~\ref{l2sat:alg} 
has the following properties.
\begin{enumerate}
\item
$F_i$ is satisfiable if and only if  $F^b_i$ is satisfiable.

\item
$F'_i$ is a {\sf 2CNF} formula which depends only on its input variables
$X^i$.

\item
The size of $F^b_i$ is polynomial in the size of the input specification.
\end{enumerate}
Now by an induction on the number of non-terminals in the definition of 
$F$ we can show that the formula $E(F)$ is satisfiable if and only the 
algorithm outputs Yes. This completes the proof of Part (1).


\noindent
Part (2): If every relation in {\sf S} 
is bijunctive, then at the start of iteration $i$ of the Repeat loop, 
we replace all the explicit clauses in $F_i$ by equivalent {\sf 2CNF} clauses.
Such a replacement can be done in polynomial time.
This observation along with the proof of Part (1) suffices to prove this part
of the theorem. \hfill\QED


We now consider the problems $\alpha$-{\sf 3SAT1WN}, $\alpha$-{\sf 3SAT1WP} and
those $\alpha$-{\sf 3SAT(S)}, for which 
every relation in {\sf S} is 1-weakly positive or
every relation in {\sf S} is 1-weakly negative. We first prove a technical
lemma about representing every 1-weakly positive or 1-weakly negative relation
as a 1-weakly positive or a 1-weakly negative formula respectively.

\begin{lemma}\label{le:satwnto3wn}
Every 1-weakly positive relation can be expressed as an existentially
quantified 3CNF formula
in which each clause is 1-weakly positive.
Every 1-weakly negative relation can be expressed as an existentially
quantified  3CNF formula
in which each clause is 1-weakly negative.
\end{lemma}


\noindent
{\bf Proof:}
We consider the case of a 1-weakly positive relation. This relation can be
expressed as a {\sf CNF} formula in which each clause has at most one negated
literal. Moreover, any such clause with a negated literal has no more than 
1 unnegated literal.
Observe that by preceding discussion it is clear that 
each clause with more than 3 literals only has unnegated
literals. For each such clause (with at least 3 literals),
$c=(v_1 \vee v_2 \vee \ldots \vee v_k)$, 
we replace $c$ with a existentially  quantified formula
$f_c$ defined as 
\[f_c \equiv \left((v_1 \vee y_1) \wedge (\overline {y_1} \vee v_2 \vee y_2)
\wedge (\overline {y_2} \vee v_3 \vee y_3) \ldots
\wedge (\overline {y_{k-2}} \vee v_{k-1} \vee y_{k-1}) 
\wedge (\overline {y_{k-1}} \vee v_{k}) \right)\]
such that the $y_i$ are existentially quantified.
By direct inspection, we get that
given an assignment to the variables $v_i$, $1 \leq i \leq k$, 
this assignment satisfies $c$ if and only if
the assignment can be extended to an assignment to the existentially 
quantified  variables $y_i$ which satisfy the formula $f$. 

A 1-weakly negative {\sf 3CNF} formula can be obtained in a similar fashion
from a 1-weakly negative relation. This completes the proof of the lemma. \hfill\QED

\smallspacing
{\small
\begin{figure}[tbp]
\rule{\textwidth}{0.01in}

\noindent
{\bf Algorithm ALG-L3SAT1WP} 

\noindent
{\bf Input:} {\it An L-specification} $F = (F_1, \ldots , F_n)$
{\it of a 3SAT1WP formula } $E(F)$.  

\noindent
{\bf Output:} {\bf Yes} {\it if and only if $E(F)$ is satisfiable.} 

\noindent
Repeat the following steps for $1 \leq i \leq n$.

\begin{enumerate}
\item
Let $F_{i_1}, \ldots, F_{i_k}$ denote the non-terminals called in $F_i$.
Replace each of the $F_{i_j}$ by the smaller set of equations $F^b_{i_j}$
that has been already computed.

\noindent
{\bf Remark:} The sizes of $F_{i_j}$, $ 1 \leq j \leq k$ is $O(n_{i_j}^3)$.
This is because the total number of distinct {\sf 3CNF} clauses that can be
constructed from a set of $n$ variables is $O(n^3)$.
Also note that, formula resulting by substituting each non-terminal with 
its corresponding burnt formula is a 1-weakly positive {\sf CNF} formula 
whose size is polynomial in the original representation of $F_i$.

\item 
Let $G_i(X^i)$ represent the set of clauses  over $X^i \cup Z^i$
obtained as a result of substitution.

\item
{\bf If} ( $ i < n  $) {\bf do}
\begin{itemize}
\item
Eliminate the variables which are
not input variables to $F_i$ 
using the method given in Algorithm \ref{dp:alg}.
The 1-weakly positive {\sf 3CNF} formula obtained after this step is $F^b_i$.

\noindent
{\bf Remark:} The variables of $F^b_i$ are the input variables of $F_i$
and the size of $F^b_i$ is $O(n_i^3)$, where $n_i$ is the number of temporary
variables occurring in the definition of $F_i$.

\end{itemize}
{\bf else}
\begin{itemize}
\item
Output {\bf Yes} if and only if the formula $G_n$ is satisfiable.
\end{itemize}
\end{enumerate}


\refstepcounter{xalgcount}\label{l3sat1wp:alg}
\begin{center}
Algorithm~\ref{l3sat1wp:alg}: Details of the algorithm to solve 
{\sf L-3SAT1WP}.
\end{center}
\vspace*{-.2in}
\rule{\textwidth}{0.01in}
\end{figure}
}

\morespacing

\begin{theorem}\label{th:h3sat1wneasy}
\begin{description}
\item{1}
The problems L-3SAT1WN and L-3SAT1WP are in P. 
\item{2}
The problems L-SAT(S) and L-SAT$_c$(S) are in P if every relation in S is
1-weakly positive or every relation in S is 1-weakly negative.
\end{description}
\end{theorem}



\noindent
{\bf Proof:}

\noindent
{\bf Part (1):} 
It is easy to see that Algorithm \ref{l3sat1wp:alg} indeed decides
in polynomial time whether an instance of {\sf L-3SAT1WP} is satisfiable. This
is because we are merely mimicking the algorithm outlined for the same problem
when instances are specified using standard specifications. The formal proof
now follows by an induction on the depth of the hierarchy tree.



\noindent
{\bf Part (2):}  
If every relation in $S$ is 1-weakly positive, then any instance of 
{\sf L-SAT(S)} or {\sf L-SAT$_c$(S)} can be expressed as an instance of 
{\sf L-3SAT1WP} using 
Lemma~\ref{le:satwnto3wn}. Moreover this transformation can be carried out
locally, so that starting from an {\sf L}-specification $F$ 
of a {\sf L-SAT(S)} 
formula, we obtain an {\sf L}-specification $F_1$ of an equivalent 
{\sf 3SAT1WP} formula in polynomial time.
We then use Algorithm \ref{l3sat1wp:alg} to solve the resulting formula.
Clearly $E(F)$ is satisfiable if and only if $E(F_1)$ is satisfiable.

Similarly, if every relation in $S$ is 1-weakly negative, 
then any instance of {\sf L-SAT(S)} or {\sf L-SAT$_c$(S)} 
can be expressed as an instance of {\sf L-3SAT1WN} using 
Lemma~\ref{le:satwnto3wn}. \hfill\QED




\subsection{Solving {\sf 1-PN-3SATWP} and  {\sf 1-PN-3SATWN}}
Next, we consider the problems {\sf 1-FPN-3SATWN}, {\sf 1-FPN-3SATWP}
{\sf 1-PN-3SATWN} and  {\sf 1-PN-3SATWP}. In contrast to the hardness results
for {\sf 1-FPN(BC)-3SATWP}, we show that
these problems have a polynomial
time algorithm. The result shows one difference between these variants
of periodic specifications. We first consider the problem {\sf 1-PN-3SATWP}.
Recall that a relation $R$ is weakly positive if $R$ is equivalent to some
{\sf CNF} formula having at most one negated variable in each conjunct. 
Given an instance $F$ of {\sf 1-FPN(BC)-3SATWP}, we assume that each clause
contains no more than one negated literal. Algorithm \ref{1pn3satwp:alg}
gives the details to solve the problem. In describing the algorithm and its
proof, we use $v[x_i(t)]$ to denote the value assigned to the variable 
$x_i(t)$.

\smallspacing
{\small
\begin{figure}[tbp]
\rule{\textwidth}{0.01in}

\noindent
{\bf Algorithm ALG-1-PN-3SATWP} 

\noindent
{\bf Input:} {\it A 1-PN-specification} $(F(U,C(t, t+1))$
{\it of a 3SATWP formula } $F^{\infty}$.  Here $U = \{ x_1, \ldots, x_n \}$
denotes the set of variables in the static graph.

\noindent
{\bf Output:} {\bf Yes} {\it if and only if $F^m$  is satisfiable.} 

\begin{enumerate}

\item
{\em flag = 0,} {\em satisfy = -1}, $r = \{ t, t+1 \}$ and $ j = 0$
\item
{\bf Repeat until} {\em flag =1 }

\begin{enumerate}

\item
If $x_i(r) \in C(t, t+1)$  and $\overline{x_i(r)} \in C(t, t+1)$, 
then set {\em flag = 1} and {\em satisfy = 0}. Go to Step 3.

\noindent
{\bf Remark:} 
For each of the four possibilities depending on the value of $r$, we have
that $\forall t \in {\bf Z}, x_i(t), ~~ \overline{x_i(t)} \in C^{\infty}$.
Hence $F^{\infty}$ is not satisfiable.



\item
{\bf If} all clauses in $C(t,t+1)$ contain a positive literal {\bf or}
all clauses in $F$ contain a negative literal {\bf then} {\em satisfy = 1}
and {\em flag = 1}. Go to Step 3.

\noindent
{\bf Remark:} 
An assignment of the form 
$\forall x_i \in C(t, t+1), ~~ t \leq r \leq t+1, ~~   v[x_i(r)] = 1$ 
satisfies the formula.

\item 
{\bf else}

\begin{enumerate}



\item
Pick a single literal clause $\overline{x_i(r)}$, $1 \leq i \leq n$.


\noindent
{\bf Remark:} Existence of such a clause follows from 
(i) the definition of 3CNF weakly positive formula, and 
(ii) Conditions for executing Step 2(b) are not satisfied.



\item
$t \leq r \leq t+1$, set $v[x_i(r)] = 0$.

\noindent
{\bf Remark:}
Existence of a clause $\overline{x_i}$ 
implies that for the formula $F^{\infty}$ to be true, 
$\forall t \in {\bf Z},~~ v[x_i(t)] = 0$.

\item
Let $N_{x_i}(t, t+1) \subseteq C(t, t+1)$ denote the set of clauses 
containing $\overline{x_i(r)}$. Also, let 
$P_{x_i}(t, t+1) \subseteq C(t, t+1)$ denote the set of clauses containing 
$x_i(r)$. Modify $P_{x_i}(t, t+1)$ by deleting the literal 
$x_i(r)$ from each of the clauses in $P_{x_i}(t, t+1)$. 
Let $P'_{x_i}(t, t+1)$ denote the resulting set of clauses.


\item $C(t,t+1) = \left( C(t, t+1) - N_{x_i}(t, t+1) - P_{x_i}(t, t+1) \right) 
\cup P'_{x_i}(t, t+1).$

\noindent
{\bf Remark:}
Delete all clauses containing  the occurrence of the variable 
$\overline{x_i(r)}$ and for all clauses which contain
$x_i(r)$ delete it from the clause. 


\item
$ j = j+1$

\noindent
{\bf Remark:}
The formula $F^{\infty}$ as a result
of modification can be given by 
\[ F_j^{\infty} = F_{j-1}^{\infty}(v[x_i(t)] = 0) 
- \left(\bigwedge_{t}P_{x_i}(t, t+1) \bigwedge_{t}N_{x_i}(t, t+1) \right) 
\bigcup \left(\bigwedge_{t}P'_{x_i}(t, t+1) \right) \]


\end{enumerate}

\item
If the formula $C(t,t+1) = \phi$ then set {\em satisfy = 1} and {\em flag = 1}.

\end{enumerate}

\item
Output {\bf Yes} if and only if {\em satisfy = 1}.

\end{enumerate}
\refstepcounter{xalgcount}\label{1pn3satwp:alg}
\begin{center}
Algorithm~\ref{1pn3satwp:alg}: 
Details of the algorithm to solve an instance of  {\sf 1-PN-3SAT1WP}.
\end{center}
\vspace*{-.2in}
\rule{\textwidth}{0.01in}
\end{figure}
}

\newspacing


First observe that our algorithm works on the static formula $F$ representing
$F^{\infty}$. Since each iteration assigns a value to a variable which has
not been previously assigned a value, the algorithm will terminate
in polynomial time. Specifically, since there are $n$ variables in the static
formula the Repeat loop is executed no more than $n$ times. Each iteration
of the repeat loop takes polynomial time and hence the whole algorithm 
can be executed in polynomial time. We also can give a succinct specification
of the satisfying assignment in case the formula $F^{\infty}$ is satisfiable.
The specification simply consists of the variables $x_1, \ldots, x_n$ together
with their associated values. 

To prove the correctness of the algorithm, it is useful to observe the
execution of the algorithm on the expanded formula $F^{\infty}$. 
First observe that if at any stage the algorithm  outputs {\bf Yes}, 
then clearly $F^{\infty}$ is satisfiable. Moreover, the satisfying assignment
assigns to each distinct variable in the static formula the same value in
each time period; i.e.  
\[ 1 \leq i \leq n, ~~ \forall t \in {\bf Z}, ~~ v[x_i(t)] = v[x_i(t+1)] \]
In the rest of the discussion, we only consider
the case when the algorithm outputs {\bf No}.  
Let $F^{\infty}(1)$ denote the formula obtained after executing the first
iteration of our algorithm.

Let the algorithm execute for $k$ steps before terminating.
By an induction  on $k$, we show that
$F^{\infty}$ is  satisfiable if only if
$F^{\infty}(k)$ is satisfiable. We prove the basis case. The induction step
follows a similar argument and is left to the reader.
Consider   the first iteration. 
We consider the possible cases depending on the Steps 
2(a), 2(b) or 2(c) executed by the algorithm.

\begin{enumerate}


\item
{\em If Step 2(a) is  executed:}
Then, depending on the value of $r$ we have four different cases:
(1) $ x_i(t), ~~ \overline{x_i(t)} \in C(t, t+1)$,
(2) $ x_i(t), ~~ \overline{x_i(t+1)} \in C(t, t+1)$, 
(3) $ x_i(t+1), ~~ \overline{x_i(t)} \in C(t, t+1)$ and 
(4) $ x_i(t+1), ~~ \overline{x_i(t+1)} \in C(t, t+1)$.
For each of the cases, it is easy to see that
$\forall t \in {\bf Z}, ~~  x_i(t), ~~ \overline{x_i(t)} \in C^{\infty}.$
Thus the formula $F^{\infty}$ is unsatisfiable.

\item
{\em If Step 2(b) is  executed:}
In this case the formula is satisfied with the assignment mentioned in the 
remark following the step.

\item
{\em Step 2(c) is executed:} 
Clearly in this case either
$x_i(t)$ or $x_i(t+1) \in C(t, t+1)$. But in either case
$\forall t \in {\bf Z}, ~~~  \overline{x_i(t)} \in C^{\infty}$. 
Hence  $~\forall t, ~ v[x_i(t)] = 0$. But this implies that 
$\forall t, ~ \overline{x_i(t)} = 1$. 
Thus, $\forall t$ if  $x_i(t)$
appears in a clause then it cannot satisfy the clause and hence
can be deleted from the clause. Similarly
any clause containing $\overline{x_i(t)}$ 
can be deleted from the formula since the 
clause is satisfiable. 
Hence the new formula $F^{\infty}(1)$ obtained as a
result of the transformation is satisfiable if and only if the original
formula $F^{\infty}$ is satisfiable.



\iffalse******
\begin{enumerate}
\item
The single literal clause is $x_i(t)$. Then, clearly 
$\forall t \in {\bf Z}, ~~~  x_i(t) \in C^{\infty}$. Hence 
$\forall t, ~~~ x_i(t) = 1$. But this implies that 
$\forall t, ~~~ \overline{x_i(t)} = 0$. 
Thus, if $\forall t \overline{x_i(t)}$
appears in a clause then it cannot satisfy the clause and hence
can be deleted from the clause. Similarly
any clause containing $x_i(t)$ can be deleted from the formula since the 
clause is satisfiable. Hence the new formula $F^{\infty}(1)$ obtained as a
result of the transformation is satisfiable if and only if the original
formula $F^{\infty}$ is satisfiable.


\item

The single literal clause is $x_i(t+1)$. 
Then by arguments similar to the ones given for Case 1, we get that
the new transformed formula is satisfiable if and only if the original formula
is satisfiable.
\end{enumerate}

***************
\fi

\end{enumerate}

The above argument implies that $F^{\infty}$ is  satisfiable if only if
$F^{\infty}(1)$ is satisfiable. Now by similar arguments we can prove the
induction Step.
Thus we have shown that the $F^{\infty}$ is satisfiable
if and only if the Algorithm \ref{1pn3satwp:alg} outputs {\bf Yes}.
A similar algorithm can be designed for {\sf 1-PN-3SATWN} problem.
Thus we have the following theorem.

\begin{theorem}\label{th:pn3satwneasy}
The problems 1-PN-3SATWN and  1-PN-3SATWP are  in P.
\end{theorem}


\iffalse**********
We need some additional notation before we prove Theorem \ref{th:pn3satwneasy}.
Given a static 1-PN specification $ F = (U, C(t,t+1))$, we obtain a new
set of formula $F'(C',U')$ as follows: 
Replace each variable $x_i(t)$ and $x_i(t+1)$
by the same variable $x_i$. This basically implies that 
we construct a set of clauses in which 
occurrence of copy of the variable $x_i$ point $t$ and $t+1$ is not
differentiated.  Observe that if $C(t, t+1)$ is a conjunction
of Horn clauses with no more than 3 literals, 
then $C'$ is also a conjunction of Horn clauses with no more than 3 literals.
We now prove the following lemma, basically implies that if an instance
of {\sf 1-PN3SATWP} is satisfiable then there always exists a 
satisfying assignment which assigns the same value to all copies of a given
variable in the static graph.


\begin{claim}
The formula $F^m$ is satisfiable if and only if the formula $F'$ 
is satisfiable.
\end{claim}

\noindent
{\bf Proof of Claim:} Let the formula $F^m(i)$ denote the formula $F^m$ 
which is obtained by assigning values to the variables according the 
algorithm. Then we show that $\forall i$ $F^m(i)$ is satisfiable if and
only $F^m$ is satisfiable. We then show that $F$ is satisfiable if and
only if $\forall i$ $F^m(i)$ is satisfiable.

Consider the first loop of the algorithm. Clearly if there is a variable which
occurs as a single literal positive as well as negative clause, then the
formula $F^m(1)$ as well as the problem $F'$ is unsatisfiable.

Now for induction step assume that after $i$ iteration, we have a formula
$F^m(i)$ which has partially assigned variables. We also have that $F^m(i)$ is
satisfiable if and only if $F^m$ is satisfiable. We also have that $F(i)$ is
satisfiable if and only if $F$ is satisfiable. Now if $F'(i+1)$ is
satisfiable then $F^m(i+1)$ and thus $F^m$ is satisfiable. Now we prove that
if $F'(i+1)$ is not satisfiable then $F^m(i)$ is unsatisfiable; hence $F^m$
is unsatisfiable. Since $F'(i+1)$ is unsatisfiable we know that 
there is a clause of the form $x_i$ and a clause of the form $\overline{x_i}$  
We have to consider the following cases.

\begin{enumerate}
\item
When both $x_i$ and $\overline{x_i}$ represent $x_i(t)$. In this case,
we know that since these clauses appear at each time unit, they cannot be
simultaneously satisfied.

\item
When $x_i$ represents $x_i(t)$ and $\overline{x_i}$ represent $x_i(t+1)$.
 Clearly, by our convention of expanding
the static graph, we know that we will have clauses of the form
$\ldots, x_i(-1), x_i(0), x_i(1), \ldots$ and we will also have clauses
$\ldots, \overline{x_i(-1)}, \overline{x_i(0)}, \overline{x_i(1)}, \ldots$.
Hence the expanded formula is not satisfiable.

\item
When both $x_i$ and $\overline{x_i}$ represent $x_i(t+1)$. Similar to Case 1.

\item
When $x_i$ represents $x_i(t+1)$ and 
$\overline{x_i}$ represent $x_i(t)$.  Similar to case 2.
\end{enumerate}
This completes the proof of the lemma. \hfill\QED

*************
\fi





\subsection{Solving {\sf 1-FPN-3SATWN} and  {\sf 1-FPN-3SATWP}}
Next, consider the problems {\sf 1-FPN3SATWP} and {\sf 1-FPN3SATWN}. 
As in the previous section, we will discuss the method for solving 
{\sf 1-FPN-3SATWP}. The algorithm for solving {\sf 1-FPN-3SATWN} is 
similar and is omitted.


\iffalse
%%%%
The algorithm for solving {\sf 1-FPN-3SATWP} 
is little more subtler then solving an
instance of {\sf 1-PN-3SATWP}. To see this observe that  in case
of {\sf 1-PN-3SATWP}, whenever we have a clause of the form $x_i(t)$ or
$x_i(t+1)$, we have that all the copies of the variable $x_i$ are set to
true (A  similar argument applies for negated clauses). But in the
case of finite instances while a clause of  the form $x_i(t)$  implies that
$x_i$ is set to true for time periods, it is not necessarily true if there
is a clause of the form $x_i(t+1)$. Such a clause does not say anything 
about the value that has to be assigned to the variable $x_i(0)$. In fact, the 
following example shows that the only way the expanded formula is satisfied
is to assign different values to the copy of a particular variable.
%%%%%
\fi



	 
\noindent
{\bf Example 5:}
Let $F= (U,C(t,t+1),2)$
be an instance of  1-FPN-3SAT where the set of static clauses are given by
$(x_1(t) + x_2(t+1))  \wedge 
(\overline{x_2(t)}) \wedge (x_2(t) + x_1(t+1))$.
The set of variables are $U = \{ x_1, x_2, x_3 \}$.
The formula $F^1(U^2,C^2)$ denoted by $\Gamma$ is given by 
\[(\overline{x_1(0)} + x_2(1)) \wedge (\overline{x_2(0)}) 
\wedge (x_1(1) + x_2(0)) \bigwedge \]
\[(\overline{x_1(1)} + x_2(2)) \wedge (\overline{x_2(1)}) 
\wedge (x_1(2) + x_2(1)) \bigwedge \]
\[(\overline{x_2(2)}) \]

By inspection it is clear that whenever $v[x_1(0)] = v[x_1(1)] = v[x_1(2)]$ and
$v[x_2(0)] = v[x_2(1)] = v[x_2(2)]$ cannot satisfy the formula $F^2$. But,
$v[x_2(0)] = v[x_2(1)] = v[x_2(2)] =0$ , $v[x_1(0)] = 1$ and 
$v[x_1(1)] = v[x_1(2)] = 0$  satisfies the formula $F^2$. \hfill\QED 




Example  5 suggests that any polynomial time  algorithm for
solving {\sf 1-FPN-3SATWP} should distinguish the between a copy of the
variable at time 0 and the copies of the same variable at time units greater
than 0.  
Algorithm~\ref{1fpn3satwp:alg} outlines the method to solve the problem.




\tinyspacing

{\footnotesize
\begin{figure}[tbp]
\rule{\textwidth}{0.01in}

\noindent
{\bf Algorithm ALG-1-FPN-3SATWP} 

\noindent
{\bf Input:} {\it A 1-FPN-specification} $(F(U, C(t,t+1),m)$
{\it of a 3SATWP formula } $F^m$.  Here $U = \{ x_1, \ldots, x_n \}$
denotes the set of variables in the static formula.

\noindent
{\bf Output:} {\bf Yes} {\it if and only if $F^m$  is satisfiable.} 

\begin{enumerate}

\item
{\em flag = 0} and {\em satisfy = -1}. Let ${\cal D}(t) = \phi$. Also let 
$ r = \{ t, t+1 \}$ and $j =0$.

\item
{\bf Repeat until} {\em flag =1 }

\begin{enumerate}

\item
If $x_i(r) \in C(t, t+1)$  and $\overline{x_i(r)} \in C(t, t+1)$, 
then set {\em flag = 1} and {\em satisfy = 0}. Go to Step 4.


\item
If $x_i(t+1) \in C(t, t+1)$  and $\overline{x_i(t+1)} \in C(t, t+1)$, 
then set {\em flag = 1} and {\em satisfy = 0}. Go to Step 4.



\item
{\bf If} all clauses in $F$ contain a positive literal {\bf or}
all clauses in $F$ contain a negative literal {\bf then} {\em satisfy = 1}
and {\em flag = 1}. Go to Step 3.


\noindent
{\bf Remark:} 
An assignment of the form 
$v[x_i(r)] = 1$, $\forall x_i \in C(t, t+1), ~~ t \leq r \leq t+1$
satisfies the clauses in $\wedge_{t =1}^{t = m} C(t, t+1)$.  Therefore,
we only need to verify that ${\cal D}(t)$ is satisfiable. 


\item 
{\bf else}

\begin{enumerate}

\item
{\bf If} there is a single literal clause $\overline{x_i(t)}$, 
$1 \leq i \leq n$ then {\bf do}

\begin{enumerate}

\item
$t \leq r \leq t+1$, set $v[x_i(r)] = 0$.

\item
If there is a clause in ${\cal D}(t)$ 
that contains $\overline{x_i(r)}$, then delete the clause.
Similarly, delete all occurrences of $x_i(r)$ from all the clauses
in ${\cal D}(t)$.

\end{enumerate}


\item
{\bf else}

\begin{enumerate}
\item
Pick a single literal clause $\overline{x_i(t+1)}$.

\noindent
{\bf Remark:} Existence of such a clause follows from 
(i) the definition of 3CNF weakly positive formula, and 
(ii) Conditions for executing Steps 2(c) and 2(d) are not satisfied.

\item
Set $v[x_i(t+1)] = 0$.

\noindent
{\bf Remark:}
Existence of a clause $\overline{x_i(t+1)}$ 
implies that for the formula $F^{\infty}$ to be true, 
$0 \leq t \leq m,~~ v[x_i(t+1)] = 0$. This does not force an assignment for
$x_i(0)$.


\item
Set ${\cal D}(t) = {\cal D}(t) \cup Cl_{x(t)}$, where $Cl_{x(t)}$ denotes the
set of clauses containing $x(t)$.
If there is a clause in ${\cal D}(t)$ that contains $\overline{x_i(t+1)}$, 
then delete the clause.
Similarly, delete all occurrences of $x_i(t+1)$ 
from all the clauses in ${\cal D}(t)$.

\noindent
{\bf Remark:} $0 \leq t \leq m,~~~ \overline{x_i(t+1)} \in C^{\infty}$ 
implies that if $F^{\infty}$ is satisfiable,  then
$1 \leq t \leq m , ~~ v[x_i(t)] = 0$.
\end{enumerate}


\item
Let $N_{x_i}(t, t+1) \subseteq C(t, t+1)$ denote the set of clauses 
containing $\overline{x_i(r)}$. Also, let 
$P_{x_i}(t, t+1) \subseteq C(t, t+1)$ denote the set of clauses containing 
$x_i(r)$. Modify $P_{x_i}(t, t+1)$ by deleting the literal 
$x_i(r)$ from each of the clauses in $P_{x_i}(t, t+1)$. 
Let $P'_{x_i}(t, t+1)$ denote the resulting set of clauses.



\item $C(t,t+1) = \left( C(t, t+1) - N_{x_i}(t, t+1) - P_{x_i}(t, t+1) \right) 
\cup P'_{x_i}(t, t+1).$

\noindent
{\bf Remark:}
Delete all clauses containing  the occurrence of the variable 
$\overline{x_i(r)}$ and for all clauses which contain
$x_i(r)$ delete it from the clause. 



\item
$ j = j+1$

\noindent
{\bf Remark:} The formula $F^{\infty}$ as a result
of modification is given by 
\[ F_j^{\infty} = F_{j-1}^{\infty}(v[x_i(t)] = 1,~ 1 \leq t \leq m) 
\bigcup {\cal D}(t) - \left(\bigwedge_{t}N_{x_i}(t, t+1) 
\bigwedge_{t}P_{x_i}(t, t+1) \right) 
\bigcup \left(\bigwedge_{t}N'_{x_i}(t, t+1) \right) \]


\end{enumerate}

\item
If the formula $F = \phi$, then set {\em satisfy = 1} and {\em flag = 1}.

\end{enumerate}

\item
Instantiate $t = 0$ for all the variables in the clauses in ${\cal D}(t)$.
Check if the clauses in ${\cal D}(0)$ are satisfiable. 
If ${\cal D}(0)$ is satisfiable then {\em satisfy = 1} else {\em satisfy = 0}.

\noindent
{\bf Remark:} All the clauses in ${\cal D}(0)$ contain variables only 
from time 0. The satisfiability of ${\cal D}(0)$  can be tested using the
procedure given in \cite{Pa94} for {\sf 3SATWP} formulas specified using
standard specification.


\item
Output {\bf Yes} if and only if {\em satisfy = 1}.


\end{enumerate}
\refstepcounter{xalgcount}\label{1fpn3satwp:alg}
\begin{center}
Algorithm~\ref{1fpn3satwp:alg}: 
Details of the algorithm to solve an instance of 
{\sf 1-FPN-3SAT1WP}.
\end{center}
\vspace*{-.2in}
\rule{\textwidth}{0.01in}
\end{figure}
}


\newspacing


\subsubsection{Proof of Correctness}
\begin{theorem}\label{th:fpn3satwneasy}
The problems 1-FPN-3SATWN and  1-FPN-3SATWP are  in P.
\end{theorem}


Before, we discuss the proof we point out the intuitive difference between the
two algorithms. In the
two way infinite periodic case, when we found a clause of type 
$\overline{x_i(t+1)}$
we could delete all the clauses containing 
$\overline{x_i(t)}$ as $\forall t$, $v[x_i(t)]$ had to be 0.
In the case of finite formulas though, the clause of the form 
$\overline{x_i(t+1)}$ does 
not force us to assign 0 to the variable $x_i(0)$. As a result, in the expanded
formula, we need to maintain the clauses containing $x_i(0)$ separately.
This is precisely what the set ${\cal D}(t)$ is used for. 
It keeps a copy of all such clauses
whose remaining variables  have not been forced an assignment and in the end
checks whether the formula is satisfiable.



\noindent
{\bf Proof:} As in the proof of the previous theorem, it will be useful to
imagine the execution of the algorithm on the expanded formula $F^m$.
The basic idea behind the proof as similar to that discussed in the proof
of Theorem \ref{th:pn3satwneasy}. Hence we only point out the essential
differences here. The difference is when we find a single literal clause
of type $\overline{x_i(t+1)}$ (or $x_i(t+1)$). In such a case we maintain
the clauses containing the variable $\overline{x_i(t)}$ (or $x_i(t)$).
Hence the theorem is proved. \hfill\QED





\iffalse*************
\begin{claim}
The formula $F^m$ is satisfiable if and only if the formula $F$ is satisfiable.
\end{claim}

\noindent
{\bf Proof of Claim:} Let the formula $F^m(i)$ denote the formula $F^m$ 
which is obtained by assigning values to the variables according the 
algorithm. Then we show that $\forall i$ $F^m(i)$ is satisfiable if and
only $F^m$ is satisfiable. We then show that $F$ is satisfiable if and
only if $\forall i$ $F^m(i)$ is satisfiable.

Consider the first loop of the algorithm. Clearly if there is a variable which
occurs as a single literal positive as well as negative clause, then the
formula $F^m(1)$ as well as the problem $F$ is unsatisfiable.

Now for induction step assume that after $i$ iteration, we have a formula
$F^m(i)$ which has partially assigned variables. We also have that $F^m(i)$ is
satisfiable if and only if $F^m$ is satisfiable. We also have that $F(i)$ is
satisfiable if and only if $F$ is satisfiable. Now we have to consider the 
following conditions.

\begin{enumerate}
\item
If there is a single literal clause of the form $x_i(r)$ and there is a clause
of the form $\overline{x_i(r)}$ then clearly since for all time units
$t \geq 2$ each of 
the clause $x_i(t)$ and $\overline{x_i(t)}$ is present.
Therefore, we must have that the formulas $F(i)$ and  
$F^m(i)$ are  unsatisfiable. Therefore, $F^m$ is unsatisfiable.



\item
When we pick a single literal clause containing $x_i(r)$, we 
delete all clauses containing
the occurrence of the variable $x_i(r)$ and for all clauses which contain
$\overline{x_i}$ delete it from the clause. Clearly $F(i+1)$ is satisfiable
if and only if $F(i)$ is satisfiable. Also, $F^m(i+1)$ in which all the single
literal clauses $x_i(t)$ have to be set to true. Similarly the negative
occurrences have to be set to false. Now $F^m(i+1)$ is satisfiable if and
only if $F^m(i)$ is satisfiable.



\end{enumerate}

******************
\fi



\iffalse*******
Clearly if $F$ is satisfiable then  it is easy to see that 
$F^m$ is satisfiable. Therefore in the remaining we prove the converse.
Suppose at some stage in the execution of the algorithm, it is found that
$F$ is unsatisfiable. We prove the claim by induction. Formally, let
$F(i)$ denote the formula obtained starting from $F$ in $i$ steps. We claim
that $F(i)$ is satisfiable if and only if $F(i-1)$ is satisfiable. 
We prove this by induction. 

\noindent
{\bf Basis:} $F$ is satisfiable if and only if $F(1)$ is  satisfiable.
The only way that $F(1)$ is unsatisfiable is by Step (1a). But this would imply
that $F^m$ is also unsatisfiable.



For proving the statement we need to consider the following cases.

\begin{enumerate}
\item
If there is a single literal clause of the form $x_i(r)$ and there is a clause
of the form $\overline{x_i(r)}$ then clearly since for all time units
$t \geq 2$ each of 
the clause $x_i(t)$ and $\overline{x_i(t)}$ is present.
Therefore, we must have that the formula $F^m$ is unsatisfiable.

\item
When we pick a single literal clause containing $x_i(r)$, we 
delete all clauses containing
the occurrence of the variable $x_i(r)$ and for all clauses which contain
$\overline{x_i}$ delete it from the clause.
\end{enumerate}
*********
\fi


 








The intuitive reason for this contrast is to do with the semantics of 
{\em implication}. 
A chain of implications of the form $A_1 \rightarrow A_2 \ldots A_m$ 
holds when $A_1 = 0$ and $ A_i = \{0,1\}$, $ 1 \leq i \leq m$.  
This means that given a {\sf 1-FPN-3SATWN} 
we can make the formula true by using the Algorithm \ref{dp:alg}.
In the case of {\sf 1-FPN(BC)-3SATWN} formula by encoding the starting ID 
of the 
machine as a boundary condition we have already assigned values to some 
variable. As a result one cannot give a trivial satisfying assignment to
all the variables thereafter.


The above theorem contrasts the relative hardness of problems when specified
using {\sf 1-FPN} or 
{\sf 1-FPN(BC)} specifications. In particular, while the
problems {\sf 1-FPN(BC)-3SATWN} and 
{\sf 1-FPN(BC)-3SATWP} are {\sf PSPACE}-hard the problems
{\sf 1-FPN-3SATWN} and {\sf 1-FPN-3SATWP} are in {\sf P}.

\section{Additional Material for Section~\ref{sec:char}}
\label{sec:appC}

\subsection{Statement and Proof of Theorem~\ref{th:hsatshard}}

\noindent
\textbf{Statement of Theorem~\ref{th:hsatshard}:}~
\begin{enumerate}
\item
If Rep(S) is the set of all finite arity Boolean relations, then\\
(a) the problem 1-FPN-SAT$_c$(S) is PSPACE-complete.
(b) The problems 1-FPN-SAT(S) and 1-PN-SAT(S) are  in P if each relation
in S is 0-valid or each relation in $S$ is 1-valid, otherwise
the problems 1-FPN-SAT(S) 1-PN-SAT(S) are  PSPACE-complete.
\item
Let S be a finite set of finite arity Boolean relations such that
Rep(S) is the set of all weakly positive or Rep(S) is the set
of all weakly negative relations. Then
the problems 1-FPN(BC)-SAT(S) and 1-FPN(BC)-SAT$_c$(S) are PSPACE-complete
\end{enumerate}

\noindent
{\bf Proof:} 

\smallskip

\noindent
{\bf  Part 1:}
First, we give a polynomial time reduction 
from {\sf 1-FPN-3SAT} to {\sf 1-FPN-SAT$_c$(S)} as follows:
Since {\sf Rep(S)} is the set of all finite arity Boolean relations,
for each such $S$ and 3CNF clause $c$,
there is an existentially quantified (but not necessarily constant-free)
$S$-formula $f_c$ such that $c=[f_c]$.
Again up to an easy renaming of variables, there are only fourteen such
formulae.

Let $F = (U, C(i, i+1), m)$ be an instance of {\sf 1-FPN-3SAT}. 
Obtain a static  formula $F'$
by replacing every clause $c \in C(i, i+1)$ with the 
existentially quantified (but not necessarily constant-free)
{\sf S}-formula $f_c$ such that $c=[f_c]$. For each of these clauses,
let $f'_c$ be the {\sf S}-formula (again, possibly with
of constants) resulting from $f_{c}$ by deleting
all quantifiers after making sure that all quantified variables are
distinct from each other and from all free variables.  Without loss of
generality, we assume that, for all clauses $c$,
all variables of $f'_c$, that are not variables
of $f$, are local to $f'_c$.
We have now obtained an instance $F'$ of {\sf 1-FPN-SAT$_c$(S)}, 
which is satisfiable if and only if $F$ was satisfiable.

\noindent
Next, we now reduce {\sf 1-FPN-SAT$_c$(S)} to {\sf 1-FPN-SAT(S)}. 
We consider the four possible cases as discussed in Lemma \ref{le:sch4.3}.


\noindent
{\bf Cases (1) and (2):} 
In both these cases it is easy to see that {\sf 1-FPN-SAT(S)}  and
{\sf 1-PN-SAT(S)} are  polynomial time solvable.\\

\noindent
{\bf Case (3):} $[x]$ and $[\overline{x}]$ are contained in 
{\sf Rep$_{NC}$(S)}.\\
In this case, we modify $F'$ to obtain $F''$ as follows.
We introduce a new variable $x$ and replace all occurrences of
0 by $[x]$ and replace all occurrences of 1 by $[\overline{x}]$ and 
replace all existentially quantified variables by new variables. \\

\noindent
{\bf Case (4):} $[x \not\equiv y] \in$  {\sf Rep$_{NC}$(S)}.\\
In this case, each relation in $S$ is complementive.
We modify $F'$ as follows to obtain $F''$.
We introduce two new variables $x(t)$ and $y(t)$ and replace all occurrences of
0   by $x(t)$ and 
replace all occurrences of 1  by $y(t)$. We then add 
the $S$-formulas $[x_t \not\equiv y_t] \wedge [x_t \not \equiv r_{t}]
[r_t \not \equiv x_{t+1}] \wedge [y_t \not\equiv s_{t}]
[s_t \not\equiv y_{t+1}]$.  
to the static $S$-formula, and 
replacing all existentially quantified variables by new variables
$z_1(t), \ldots z_p(t)$.
Since $F'$ is complementive, $F''$ is also complementive.



Therefore, we have now obtained an instance $F''$ 
of {\sf 1-FPN-SAT(S)}, which is satisfiable
if and only if $F'$ was satisfiable. Clearly the hardness of
{\sf 1-FPN-SAT(S)} implies the hardness of the corresponding problems 
{\sf 1-PN-SAT(S)}.


\noindent
{\bf Part (2): }
We prove  this part for the problem {\sf 1-FPN(BC)-3SAT(S)}, when 
{\sf S} represents the set of all weakly negative relations.
The proof for {\sf 1-FPN(BC)-3SAT(S)} when {\sf S} represents 
the set of all weakly positive relations is similar and omitted.

We first prove the {\sf PSPACE}-hardness of {\sf 1-FPN-SAT$_c$(S)}
when {\sf Rep(S)} is the set of all weakly negative relations.
Since {\sf Rep(S)} is the set of all weakly negative  Boolean relations,
for each such {\sf S} and {\sf 3CNF} clause $c$,
there is an existentially quantified (but not necessarily constant-free)
{\sf S}-formula $f_c$ such that $c=[f_c]$. 

Let $F$ be an instance of {\sf 1-FPN-3SATWN}. 
Obtain a {\sf 1-FPN}-specification $F'$ 
by replacing every clause $c \in C(i, i+1)$ with the 
existentially quantified (but not necessarily constant-free)
{\sf S}-formula $f_c$ such that $c=[f_c]$. For each of these clauses,
let $f'_c$ be the {\sf S}-formula (again, possibly with
constants) resulting from $f_{c}$ by deleting
all quantifiers after making sure that all quantified variables are
distinct from each other and from all free variables.  Without loss of
generality, we assume that, for all clauses $c$,
all variables of $f'_c$, that are not variables
of $f$, are local to $f'_c$.
Observe that the transformation is carried out by introducing temporary
variables $x_1(i), \ldots, x_r(i)$.
We have now obtained an instance $F'$ of {\sf 1-FPN-SAT$_c$(S)}, 
which is satisfiable if and only if $F$ was satisfiable. 

Next, we consider the case  of {\sf 1-FPNSAT(S)} when $Rep(S)$ 
represent all weakly positive relations. 
Clearly $[x]$ and $[\overline{x}]$  are in {\sf Rep(S)}.
This implies that 
\begin{enumerate}
\item
Each relation in {\sf S} is not 0-valid and

\item
Each relation in {\sf S} is not 1-valid.
\end{enumerate}
By Theorem \ref{le:sch4.3}, we have to consider two possible cases:
(a) {\em when $[x]$ and $[\overline{x}]$ is in {\sf Rep}$_{NC}$({\sf S}}) and
(b) {\em when $[x \not\equiv y ]$  is in {\sf Rep}$_{NC}$({\sf S}}).
The proof in both the cases is similar to that in Part 1. \hfill\QED

\subsection{Statement and Proof of Theorem~\ref{th:hsat_charcterize4}}

\noindent
\textbf{Statement of Theorem~\ref{th:hsat_charcterize4}:}~
Let S be a finite set of finite arity Boolean relations. Let conditions
(a) through (e) be defined as follows.
%\begin{description}
%\item{(a)}
(a) Every relation in S is 0-valid or every relation in $S$ is 1-valid.
%%\item{(b)}
(b) Every relation in S is 1-weakly positive or
every relation in S is 1-weakly negative.
%%\item{(c)}
(c) Every relation in S is weakly positive or
every relation in S is weakly negative.
%%\item{(d)}
(d) Every relation in S is affine.
%%\item{(e)}
(e) Every relation in S is bijunctive.
%%\end{description}
\begin{enumerate}
\item
If $S$ satisfies one of the conditions (b), (d) or (e)
then L-SAT$_c$(S) and 1-FPN(BC)-SAT$_c$(S) are in P; otherwise,
L-SAT$_c$(S), 1-FPN(BC)-SAT$_c$(S) are  PSPACE-complete.

\item
If $S$ satisfies one of the conditions (a), (b), (d) or (e)
then L-SAT(S) and 1-FPN(BC)-SAT(S) are in P; otherwise, L-SAT(S)and 
1-FPN(BC)-SAT(S) are PSPACE-complete.

\item
If {\bf S} satisfies conditions (a), (b), (c), (d) or  (e), then the problems  
{\sf 1-FPN-SAT(S)} and PN-SAT(S)  are in P. Otherwise, 
the problems  {\sf 1-FPN-SAT(S)} and PN-SAT(S)  are  PSPACE-complete.
\end{enumerate}

\noindent
\textbf{Proof:} 

\noindent
{\bf Proof of Part 1.}\\
We first prove the theorem for the problems L-SAT$_c$(S).
By Theorem~\ref{th:sch3.0}, we have to consider five possible cases
depending on the type of relations in $S$. In the rest of the proof we
consider each of these cases in detail.

\noindent
{\em 1. Every relation in {\sf S} is weakly positive.}\\
By Theorem \ref{th:sch3.0} this implies that 
every relation in {\sf Rep(S)} is weakly positive. 
We need to consider two subcases in order to characterize weakly positive
relations:

{\em  1(a). Every relation in {\sf S} is 1-weakly positive.}\\
In this case, 
{\sf L-SAT$_c$(S)} is in {\sf P} by Theorem~\ref{th:h3sat1wneasy}.

{\em   1(b). Some relation in {\sf S} is not 1-weakly positive.}\\
In this case by Theorem~\ref{th:sch5.1}, 
{\sf Rep(S)} is the set of all weakly positive relations.
Hence, {\sf L-SAT$_c$(S)} 
is {\sf PSPACE}-complete by Theorems~\ref{th:fpn3satwnhard}
and \ref{th:translate}.

\noindent
{\em 2. Every relation in {\sf S} is weakly negative.}\\
Similar to Case 1.

\noindent
{\em 3. Every relation in {\sf S} is affine.}\\
By Theorem~\ref{th:sch3.0}, this implies that
every relation in {\sf Rep(S)} is affine. Hence, 
by Theorem~\ref{th:haffineeasy}
{\sf L-SAT$_c$(S)} is in {\sf P}. 

\noindent
{\em 4.  Every relation in {\sf S} is bijunctive.}\\
By Theorem~\ref{th:sch3.0}, if every relation in {\sf S} is bijunctive,
then every relation in {\sf Rep(S)} is bijunctive. Hence, {\sf L-SAT$_c$(S)} 
is in {\sf P}  by Theorem~\ref{th:h2satseasy}.

\noindent
{\em 5. {\sf Rep(S)} is the set of all logical relations.}\\
In this case {\sf L-SAT$_c$(S)} 
is {\sf PSPACE}-complete by Theorem~\ref{th:hsatshard}.


Next we prove the theorem for {\sf 1-FPN(BC)-SAT$_c$(S)}.
By our translation theorem, we know that whenever a {\sf L}-specified
problem is in {\sf P}, the corresponding {\sf 1-FPN(BC)}-specified problem 
is also in {\sf P}.
next, observe that the cases for which an L-specified problem has been
proved to be {\sf PSPACE}-complete, the proof actually consists of showing that
the corresponding problems are {\sf PSPACE}-complete for {\sf 1-FPN(BC)} 
specified instances. The proof now follows by these two facts.\\



\noindent
{\bf Proof of Part 2.}
We now prove the theorem for the problems {\sf L-SAT(S)} and
{\sf 1-FPN(BC)-SAT(S)}.  Since the problems
{\sf L-SAT(S)} are a subset of the problems {\sf L-SAT$_c$(S)} 
we get that whenever a problem {\sf L-SAT$_c$(S)} is  in 
P the corresponding problem {\sf L-SAT(S)} is also
in {\sf P}. Hence we need to consider three possible cases.

\noindent
{\em 1.  Every relation in {\sf S} is weakly positive and at least one relation
in {\sf S} is not weakly positive.}\\
In this case, by Theorems \ref{th:fpn3satwnhard} and \ref{th:translate}, 
we have that {\sf L-SAT(S)} is {\sf PSPACE}-complete.

\noindent
{\em 2. Every relation in {\sf S} is weakly negative and at least one relation
in {\sf S} is not weakly negative.}\\
In this case, by Theorems \ref{th:fpn3satwnhard} and \ref{th:translate}, 
we have that {\sf L-SAT(S)} is
{\sf PSPACE}-complete.

\noindent
{\em  3. {\sf Rep(S)}  is the set of all logical relations.}\\
By Theorem~\ref{th:hsatshard}, we have that if 
every relation in {\sf S} is 0-valid or every relation 
in {\sf S} is 1-valid then {\sf L-SAT(S)} is in {\sf P}
else the problem is {\sf PSPACE}-complete.



Next, consider {\sf 1-FPN(BC)-SAT(S)}. 
As in the proof of Part 1, we know that whenever a {\sf L}-specified
problem is in {\sf P}, 
the corresponding {\sf 1-FPN(BC)}-specified problem is also in {\sf P}.
next, observe that the cases for which an {\sf L}-specified problem has been
proved to be {\sf PSPACE}-complete, the proof actually consists of showing that
the corresponding problems are {\sf PSPACE}-complete for {\sf 1-FPN(BC)} 
specified instances. The proof of this part now follows by these two facts.\\


\noindent
{\bf Proof of Part 3.}
If {\sf S} satisfies conditions (a), (b), (d) or (e) then 
by the proof of Part 2 above, the problems
{\sf 1-FPN-SAT(S)} and {\sf 1-PN-SAT(S)} are in {\sf P}. 
Therefore we need to consider only the following cases to complete the proof.


\noindent
{\em 1. Every relation in {\sf S} is weakly positive or every relation in
{\sf S} is weakly negative}.\\
In this case by Theorems \ref{th:fpn3satwneasy} and \ref{th:pn3satwneasy}
the problems {\sf 1-FPN-3SATWP} , {\sf 1-FPN-3SATWN}, {\sf 1-PN-3SATWP}  and
{\sf 1-PN-3SATWN}  are in {\sf P}.

\noindent
{\em 2. When none of (a), (b), (c), (d) and (e) hold}\\
In this case we know that {\sf Rep(S)} is equal to the set
of all finite arity Boolean relations. Since condition (a) does not hold,
by Theorem \ref{th:hsatshard}, we have that 
{\sf 1-FPN-SAT(S)} and {\sf 1-PN-SAT(S)} are {\sf PSPACE}-complete.

This completes the proof of the theorem. \hfill\QED
